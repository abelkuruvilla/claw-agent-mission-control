// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stories.sql

package db

import (
	"context"
	"database/sql"
)

const countPassedStories = `-- name: CountPassedStories :one
SELECT COUNT(*) FROM stories WHERE task_id = ? AND passes = TRUE
`

func (q *Queries) CountPassedStories(ctx context.Context, taskID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPassedStories, taskID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTotalStories = `-- name: CountTotalStories :one
SELECT COUNT(*) FROM stories WHERE task_id = ?
`

func (q *Queries) CountTotalStories(ctx context.Context, taskID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTotalStories, taskID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createStory = `-- name: CreateStory :one
INSERT INTO stories (id, task_id, sequence, title, description, priority, acceptance_criteria)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, task_id, sequence, title, description, priority, passes, acceptance_criteria, iterations, last_error, session_key, created_at, updated_at
`

type CreateStoryParams struct {
	ID                 string         `json:"id"`
	TaskID             string         `json:"task_id"`
	Sequence           int64          `json:"sequence"`
	Title              string         `json:"title"`
	Description        sql.NullString `json:"description"`
	Priority           sql.NullInt64  `json:"priority"`
	AcceptanceCriteria sql.NullString `json:"acceptance_criteria"`
}

func (q *Queries) CreateStory(ctx context.Context, arg CreateStoryParams) (Story, error) {
	row := q.db.QueryRowContext(ctx, createStory,
		arg.ID,
		arg.TaskID,
		arg.Sequence,
		arg.Title,
		arg.Description,
		arg.Priority,
		arg.AcceptanceCriteria,
	)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Sequence,
		&i.Title,
		&i.Description,
		&i.Priority,
		&i.Passes,
		&i.AcceptanceCriteria,
		&i.Iterations,
		&i.LastError,
		&i.SessionKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteStory = `-- name: DeleteStory :exec
DELETE FROM stories WHERE id = ?
`

func (q *Queries) DeleteStory(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteStory, id)
	return err
}

const getNextPendingStory = `-- name: GetNextPendingStory :one
SELECT id, task_id, sequence, title, description, priority, passes, acceptance_criteria, iterations, last_error, session_key, created_at, updated_at FROM stories WHERE task_id = ? AND passes = FALSE ORDER BY priority ASC, sequence ASC LIMIT 1
`

func (q *Queries) GetNextPendingStory(ctx context.Context, taskID string) (Story, error) {
	row := q.db.QueryRowContext(ctx, getNextPendingStory, taskID)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Sequence,
		&i.Title,
		&i.Description,
		&i.Priority,
		&i.Passes,
		&i.AcceptanceCriteria,
		&i.Iterations,
		&i.LastError,
		&i.SessionKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStory = `-- name: GetStory :one
SELECT id, task_id, sequence, title, description, priority, passes, acceptance_criteria, iterations, last_error, session_key, created_at, updated_at FROM stories WHERE id = ? LIMIT 1
`

func (q *Queries) GetStory(ctx context.Context, id string) (Story, error) {
	row := q.db.QueryRowContext(ctx, getStory, id)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Sequence,
		&i.Title,
		&i.Description,
		&i.Priority,
		&i.Passes,
		&i.AcceptanceCriteria,
		&i.Iterations,
		&i.LastError,
		&i.SessionKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listStoriesByTask = `-- name: ListStoriesByTask :many
SELECT id, task_id, sequence, title, description, priority, passes, acceptance_criteria, iterations, last_error, session_key, created_at, updated_at FROM stories WHERE task_id = ? ORDER BY priority ASC, sequence ASC
`

func (q *Queries) ListStoriesByTask(ctx context.Context, taskID string) ([]Story, error) {
	rows, err := q.db.QueryContext(ctx, listStoriesByTask, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Story{}
	for rows.Next() {
		var i Story
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Sequence,
			&i.Title,
			&i.Description,
			&i.Priority,
			&i.Passes,
			&i.AcceptanceCriteria,
			&i.Iterations,
			&i.LastError,
			&i.SessionKey,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markStoryFailed = `-- name: MarkStoryFailed :exec
UPDATE stories SET passes = FALSE, last_error = ?, iterations = iterations + 1, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type MarkStoryFailedParams struct {
	LastError sql.NullString `json:"last_error"`
	ID        string         `json:"id"`
}

func (q *Queries) MarkStoryFailed(ctx context.Context, arg MarkStoryFailedParams) error {
	_, err := q.db.ExecContext(ctx, markStoryFailed, arg.LastError, arg.ID)
	return err
}

const markStoryPassed = `-- name: MarkStoryPassed :exec
UPDATE stories SET passes = TRUE, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) MarkStoryPassed(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markStoryPassed, id)
	return err
}

const updateStory = `-- name: UpdateStory :one
UPDATE stories SET
    title = ?, description = ?, priority = ?, passes = ?,
    acceptance_criteria = ?, iterations = ?, last_error = ?,
    session_key = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ? RETURNING id, task_id, sequence, title, description, priority, passes, acceptance_criteria, iterations, last_error, session_key, created_at, updated_at
`

type UpdateStoryParams struct {
	Title              string         `json:"title"`
	Description        sql.NullString `json:"description"`
	Priority           sql.NullInt64  `json:"priority"`
	Passes             sql.NullBool   `json:"passes"`
	AcceptanceCriteria sql.NullString `json:"acceptance_criteria"`
	Iterations         sql.NullInt64  `json:"iterations"`
	LastError          sql.NullString `json:"last_error"`
	SessionKey         sql.NullString `json:"session_key"`
	ID                 string         `json:"id"`
}

func (q *Queries) UpdateStory(ctx context.Context, arg UpdateStoryParams) (Story, error) {
	row := q.db.QueryRowContext(ctx, updateStory,
		arg.Title,
		arg.Description,
		arg.Priority,
		arg.Passes,
		arg.AcceptanceCriteria,
		arg.Iterations,
		arg.LastError,
		arg.SessionKey,
		arg.ID,
	)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Sequence,
		&i.Title,
		&i.Description,
		&i.Priority,
		&i.Passes,
		&i.AcceptanceCriteria,
		&i.Iterations,
		&i.LastError,
		&i.SessionKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
