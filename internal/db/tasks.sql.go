// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tasks.sql

package db

import (
	"context"
	"database/sql"
)

const appendProgressTxt = `-- name: AppendProgressTxt :exec
UPDATE tasks SET progress_txt = COALESCE(progress_txt || char(10), '') || ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type AppendProgressTxtParams struct {
	ProgressTxt sql.NullString `json:"progress_txt"`
	ID          string         `json:"id"`
}

func (q *Queries) AppendProgressTxt(ctx context.Context, arg AppendProgressTxtParams) error {
	_, err := q.db.ExecContext(ctx, appendProgressTxt, arg.ProgressTxt, arg.ID)
	return err
}

const clearTaskRetryAt = `-- name: ClearTaskRetryAt :exec
UPDATE tasks SET retry_at = NULL, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) ClearTaskRetryAt(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, clearTaskRetryAt, id)
	return err
}

const clearTaskScheduledAt = `-- name: ClearTaskScheduledAt :exec
UPDATE tasks SET scheduled_at = NULL, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) ClearTaskScheduledAt(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, clearTaskScheduledAt, id)
	return err
}

const countActiveTasksByAgent = `-- name: CountActiveTasksByAgent :one
SELECT COUNT(*) FROM tasks WHERE agent_id = ? AND status IN ('executing', 'planning', 'discussing', 'verifying')
`

func (q *Queries) CountActiveTasksByAgent(ctx context.Context, agentID sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActiveTasksByAgent, agentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (id, title, description, agent_id, project_id, parent_task_id, status, priority, quality_checks, delegation_mode, scheduled_at, git_branch)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, title, description, agent_id, project_id, parent_task_id, status, priority, git_branch, project_md, requirements_md, roadmap_md, state_md, prd_json, progress_txt, quality_checks, created_at, updated_at, started_at, completed_at, delegation_mode, retry_count, scheduled_at, retry_at
`

type CreateTaskParams struct {
	ID             string         `json:"id"`
	Title          string         `json:"title"`
	Description    sql.NullString `json:"description"`
	AgentID        sql.NullString `json:"agent_id"`
	ProjectID      sql.NullString `json:"project_id"`
	ParentTaskID   sql.NullString `json:"parent_task_id"`
	Status         sql.NullString `json:"status"`
	Priority       sql.NullInt64  `json:"priority"`
	QualityChecks  sql.NullString `json:"quality_checks"`
	DelegationMode sql.NullString `json:"delegation_mode"`
	ScheduledAt    sql.NullTime   `json:"scheduled_at"`
	GitBranch      sql.NullString `json:"git_branch"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, createTask,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.AgentID,
		arg.ProjectID,
		arg.ParentTaskID,
		arg.Status,
		arg.Priority,
		arg.QualityChecks,
		arg.DelegationMode,
		arg.ScheduledAt,
		arg.GitBranch,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.AgentID,
		&i.ProjectID,
		&i.ParentTaskID,
		&i.Status,
		&i.Priority,
		&i.GitBranch,
		&i.ProjectMd,
		&i.RequirementsMd,
		&i.RoadmapMd,
		&i.StateMd,
		&i.PrdJson,
		&i.ProgressTxt,
		&i.QualityChecks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DelegationMode,
		&i.RetryCount,
		&i.ScheduledAt,
		&i.RetryAt,
	)
	return i, err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE id = ?
`

func (q *Queries) DeleteTask(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTask, id)
	return err
}

const getTask = `-- name: GetTask :one
SELECT id, title, description, agent_id, project_id, parent_task_id, status, priority, git_branch, project_md, requirements_md, roadmap_md, state_md, prd_json, progress_txt, quality_checks, created_at, updated_at, started_at, completed_at, delegation_mode, retry_count, scheduled_at, retry_at FROM tasks WHERE id = ? LIMIT 1
`

func (q *Queries) GetTask(ctx context.Context, id string) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.AgentID,
		&i.ProjectID,
		&i.ParentTaskID,
		&i.Status,
		&i.Priority,
		&i.GitBranch,
		&i.ProjectMd,
		&i.RequirementsMd,
		&i.RoadmapMd,
		&i.StateMd,
		&i.PrdJson,
		&i.ProgressTxt,
		&i.QualityChecks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DelegationMode,
		&i.RetryCount,
		&i.ScheduledAt,
		&i.RetryAt,
	)
	return i, err
}

const getTaskWithStoryCounts = `-- name: GetTaskWithStoryCounts :one
SELECT 
    t.id, t.title, t.description, t.agent_id, t.project_id, t.parent_task_id, t.status, t.priority, t.git_branch, t.project_md, t.requirements_md, t.roadmap_md, t.state_md, t.prd_json, t.progress_txt, t.quality_checks, t.created_at, t.updated_at, t.started_at, t.completed_at, t.delegation_mode, t.retry_count, t.scheduled_at, t.retry_at,
    (SELECT COUNT(*) FROM stories WHERE task_id = t.id) as stories_total,
    (SELECT COUNT(*) FROM stories WHERE task_id = t.id AND passes = 1) as stories_passed
FROM tasks t WHERE t.id = ? LIMIT 1
`

type GetTaskWithStoryCountsRow struct {
	ID             string         `json:"id"`
	Title          string         `json:"title"`
	Description    sql.NullString `json:"description"`
	AgentID        sql.NullString `json:"agent_id"`
	ProjectID      sql.NullString `json:"project_id"`
	ParentTaskID   sql.NullString `json:"parent_task_id"`
	Status         sql.NullString `json:"status"`
	Priority       sql.NullInt64  `json:"priority"`
	GitBranch      sql.NullString `json:"git_branch"`
	ProjectMd      sql.NullString `json:"project_md"`
	RequirementsMd sql.NullString `json:"requirements_md"`
	RoadmapMd      sql.NullString `json:"roadmap_md"`
	StateMd        sql.NullString `json:"state_md"`
	PrdJson        sql.NullString `json:"prd_json"`
	ProgressTxt    sql.NullString `json:"progress_txt"`
	QualityChecks  sql.NullString `json:"quality_checks"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	StartedAt      sql.NullTime   `json:"started_at"`
	CompletedAt    sql.NullTime   `json:"completed_at"`
	DelegationMode sql.NullString `json:"delegation_mode"`
	RetryCount     int64          `json:"retry_count"`
	ScheduledAt    sql.NullTime   `json:"scheduled_at"`
	RetryAt        sql.NullTime   `json:"retry_at"`
	StoriesTotal   int64          `json:"stories_total"`
	StoriesPassed  int64          `json:"stories_passed"`
}

func (q *Queries) GetTaskWithStoryCounts(ctx context.Context, id string) (GetTaskWithStoryCountsRow, error) {
	row := q.db.QueryRowContext(ctx, getTaskWithStoryCounts, id)
	var i GetTaskWithStoryCountsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.AgentID,
		&i.ProjectID,
		&i.ParentTaskID,
		&i.Status,
		&i.Priority,
		&i.GitBranch,
		&i.ProjectMd,
		&i.RequirementsMd,
		&i.RoadmapMd,
		&i.StateMd,
		&i.PrdJson,
		&i.ProgressTxt,
		&i.QualityChecks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DelegationMode,
		&i.RetryCount,
		&i.ScheduledAt,
		&i.RetryAt,
		&i.StoriesTotal,
		&i.StoriesPassed,
	)
	return i, err
}

const incrementTaskRetryCount = `-- name: IncrementTaskRetryCount :exec
UPDATE tasks SET retry_count = retry_count + 1, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) IncrementTaskRetryCount(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, incrementTaskRetryCount, id)
	return err
}

const listQueuedTasksByAgent = `-- name: ListQueuedTasksByAgent :many
SELECT id, title, description, agent_id, project_id, parent_task_id, status, priority, git_branch, project_md, requirements_md, roadmap_md, state_md, prd_json, progress_txt, quality_checks, created_at, updated_at, started_at, completed_at, delegation_mode, retry_count, scheduled_at, retry_at FROM tasks WHERE agent_id = ? AND status = 'queued' ORDER BY priority ASC, created_at ASC
`

func (q *Queries) ListQueuedTasksByAgent(ctx context.Context, agentID sql.NullString) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listQueuedTasksByAgent, agentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.AgentID,
			&i.ProjectID,
			&i.ParentTaskID,
			&i.Status,
			&i.Priority,
			&i.GitBranch,
			&i.ProjectMd,
			&i.RequirementsMd,
			&i.RoadmapMd,
			&i.StateMd,
			&i.PrdJson,
			&i.ProgressTxt,
			&i.QualityChecks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DelegationMode,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.RetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRetryDueTasks = `-- name: ListRetryDueTasks :many
SELECT id, title, description, agent_id, project_id, parent_task_id, status, priority, git_branch, project_md, requirements_md, roadmap_md, state_md, prd_json, progress_txt, quality_checks, created_at, updated_at, started_at, completed_at, delegation_mode, retry_count, scheduled_at, retry_at FROM tasks
WHERE retry_at IS NOT NULL
  AND retry_at <= CURRENT_TIMESTAMP
  AND status = 'backlog'
ORDER BY retry_at ASC
`

func (q *Queries) ListRetryDueTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listRetryDueTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.AgentID,
			&i.ProjectID,
			&i.ParentTaskID,
			&i.Status,
			&i.Priority,
			&i.GitBranch,
			&i.ProjectMd,
			&i.RequirementsMd,
			&i.RoadmapMd,
			&i.StateMd,
			&i.PrdJson,
			&i.ProgressTxt,
			&i.QualityChecks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DelegationMode,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.RetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listScheduledDueTasks = `-- name: ListScheduledDueTasks :many
SELECT id, title, description, agent_id, project_id, parent_task_id, status, priority, git_branch, project_md, requirements_md, roadmap_md, state_md, prd_json, progress_txt, quality_checks, created_at, updated_at, started_at, completed_at, delegation_mode, retry_count, scheduled_at, retry_at FROM tasks
WHERE scheduled_at IS NOT NULL
  AND scheduled_at <= CURRENT_TIMESTAMP
  AND status = 'backlog'
ORDER BY scheduled_at ASC
`

func (q *Queries) ListScheduledDueTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listScheduledDueTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.AgentID,
			&i.ProjectID,
			&i.ParentTaskID,
			&i.Status,
			&i.Priority,
			&i.GitBranch,
			&i.ProjectMd,
			&i.RequirementsMd,
			&i.RoadmapMd,
			&i.StateMd,
			&i.PrdJson,
			&i.ProgressTxt,
			&i.QualityChecks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DelegationMode,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.RetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaleTasks = `-- name: ListStaleTasks :many
SELECT id, title, description, agent_id, project_id, parent_task_id, status, priority, git_branch, project_md, requirements_md, roadmap_md, state_md, prd_json, progress_txt, quality_checks, created_at, updated_at, started_at, completed_at, delegation_mode, retry_count, scheduled_at, retry_at FROM tasks
WHERE status IN ('executing', 'planning', 'discussing', 'verifying')
  AND (updated_at IS NULL OR updated_at < ?)
ORDER BY updated_at ASC
`

func (q *Queries) ListStaleTasks(ctx context.Context, updatedAt sql.NullTime) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listStaleTasks, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.AgentID,
			&i.ProjectID,
			&i.ParentTaskID,
			&i.Status,
			&i.Priority,
			&i.GitBranch,
			&i.ProjectMd,
			&i.RequirementsMd,
			&i.RoadmapMd,
			&i.StateMd,
			&i.PrdJson,
			&i.ProgressTxt,
			&i.QualityChecks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DelegationMode,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.RetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubtasks = `-- name: ListSubtasks :many
SELECT id, title, description, agent_id, project_id, parent_task_id, status, priority, git_branch, project_md, requirements_md, roadmap_md, state_md, prd_json, progress_txt, quality_checks, created_at, updated_at, started_at, completed_at, delegation_mode, retry_count, scheduled_at, retry_at FROM tasks WHERE parent_task_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListSubtasks(ctx context.Context, parentTaskID sql.NullString) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listSubtasks, parentTaskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.AgentID,
			&i.ProjectID,
			&i.ParentTaskID,
			&i.Status,
			&i.Priority,
			&i.GitBranch,
			&i.ProjectMd,
			&i.RequirementsMd,
			&i.RoadmapMd,
			&i.StateMd,
			&i.PrdJson,
			&i.ProgressTxt,
			&i.QualityChecks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DelegationMode,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.RetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT id, title, description, agent_id, project_id, parent_task_id, status, priority, git_branch, project_md, requirements_md, roadmap_md, state_md, prd_json, progress_txt, quality_checks, created_at, updated_at, started_at, completed_at, delegation_mode, retry_count, scheduled_at, retry_at FROM tasks ORDER BY priority ASC, created_at DESC
`

func (q *Queries) ListTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.AgentID,
			&i.ProjectID,
			&i.ParentTaskID,
			&i.Status,
			&i.Priority,
			&i.GitBranch,
			&i.ProjectMd,
			&i.RequirementsMd,
			&i.RoadmapMd,
			&i.StateMd,
			&i.PrdJson,
			&i.ProgressTxt,
			&i.QualityChecks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DelegationMode,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.RetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByAgent = `-- name: ListTasksByAgent :many
SELECT id, title, description, agent_id, project_id, parent_task_id, status, priority, git_branch, project_md, requirements_md, roadmap_md, state_md, prd_json, progress_txt, quality_checks, created_at, updated_at, started_at, completed_at, delegation_mode, retry_count, scheduled_at, retry_at FROM tasks WHERE agent_id = ? ORDER BY created_at DESC
`

func (q *Queries) ListTasksByAgent(ctx context.Context, agentID sql.NullString) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksByAgent, agentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.AgentID,
			&i.ProjectID,
			&i.ParentTaskID,
			&i.Status,
			&i.Priority,
			&i.GitBranch,
			&i.ProjectMd,
			&i.RequirementsMd,
			&i.RoadmapMd,
			&i.StateMd,
			&i.PrdJson,
			&i.ProgressTxt,
			&i.QualityChecks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DelegationMode,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.RetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByProject = `-- name: ListTasksByProject :many
SELECT id, title, description, agent_id, project_id, parent_task_id, status, priority, git_branch, project_md, requirements_md, roadmap_md, state_md, prd_json, progress_txt, quality_checks, created_at, updated_at, started_at, completed_at, delegation_mode, retry_count, scheduled_at, retry_at FROM tasks WHERE project_id = ? ORDER BY priority ASC, created_at DESC
`

func (q *Queries) ListTasksByProject(ctx context.Context, projectID sql.NullString) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.AgentID,
			&i.ProjectID,
			&i.ParentTaskID,
			&i.Status,
			&i.Priority,
			&i.GitBranch,
			&i.ProjectMd,
			&i.RequirementsMd,
			&i.RoadmapMd,
			&i.StateMd,
			&i.PrdJson,
			&i.ProgressTxt,
			&i.QualityChecks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DelegationMode,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.RetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByStatus = `-- name: ListTasksByStatus :many
SELECT id, title, description, agent_id, project_id, parent_task_id, status, priority, git_branch, project_md, requirements_md, roadmap_md, state_md, prd_json, progress_txt, quality_checks, created_at, updated_at, started_at, completed_at, delegation_mode, retry_count, scheduled_at, retry_at FROM tasks WHERE status = ? ORDER BY priority ASC, created_at DESC
`

func (q *Queries) ListTasksByStatus(ctx context.Context, status sql.NullString) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.AgentID,
			&i.ProjectID,
			&i.ParentTaskID,
			&i.Status,
			&i.Priority,
			&i.GitBranch,
			&i.ProjectMd,
			&i.RequirementsMd,
			&i.RoadmapMd,
			&i.StateMd,
			&i.PrdJson,
			&i.ProgressTxt,
			&i.QualityChecks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DelegationMode,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.RetryAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksWithStoryCounts = `-- name: ListTasksWithStoryCounts :many
SELECT 
    t.id, t.title, t.description, t.agent_id, t.project_id, t.parent_task_id, t.status, t.priority, t.git_branch, t.project_md, t.requirements_md, t.roadmap_md, t.state_md, t.prd_json, t.progress_txt, t.quality_checks, t.created_at, t.updated_at, t.started_at, t.completed_at, t.delegation_mode, t.retry_count, t.scheduled_at, t.retry_at,
    (SELECT COUNT(*) FROM stories WHERE task_id = t.id) as stories_total,
    (SELECT COUNT(*) FROM stories WHERE task_id = t.id AND passes = 1) as stories_passed
FROM tasks t ORDER BY t.priority ASC, t.created_at DESC
`

type ListTasksWithStoryCountsRow struct {
	ID             string         `json:"id"`
	Title          string         `json:"title"`
	Description    sql.NullString `json:"description"`
	AgentID        sql.NullString `json:"agent_id"`
	ProjectID      sql.NullString `json:"project_id"`
	ParentTaskID   sql.NullString `json:"parent_task_id"`
	Status         sql.NullString `json:"status"`
	Priority       sql.NullInt64  `json:"priority"`
	GitBranch      sql.NullString `json:"git_branch"`
	ProjectMd      sql.NullString `json:"project_md"`
	RequirementsMd sql.NullString `json:"requirements_md"`
	RoadmapMd      sql.NullString `json:"roadmap_md"`
	StateMd        sql.NullString `json:"state_md"`
	PrdJson        sql.NullString `json:"prd_json"`
	ProgressTxt    sql.NullString `json:"progress_txt"`
	QualityChecks  sql.NullString `json:"quality_checks"`
	CreatedAt      sql.NullTime   `json:"created_at"`
	UpdatedAt      sql.NullTime   `json:"updated_at"`
	StartedAt      sql.NullTime   `json:"started_at"`
	CompletedAt    sql.NullTime   `json:"completed_at"`
	DelegationMode sql.NullString `json:"delegation_mode"`
	RetryCount     int64          `json:"retry_count"`
	ScheduledAt    sql.NullTime   `json:"scheduled_at"`
	RetryAt        sql.NullTime   `json:"retry_at"`
	StoriesTotal   int64          `json:"stories_total"`
	StoriesPassed  int64          `json:"stories_passed"`
}

func (q *Queries) ListTasksWithStoryCounts(ctx context.Context) ([]ListTasksWithStoryCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTasksWithStoryCounts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTasksWithStoryCountsRow{}
	for rows.Next() {
		var i ListTasksWithStoryCountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.AgentID,
			&i.ProjectID,
			&i.ParentTaskID,
			&i.Status,
			&i.Priority,
			&i.GitBranch,
			&i.ProjectMd,
			&i.RequirementsMd,
			&i.RoadmapMd,
			&i.StateMd,
			&i.PrdJson,
			&i.ProgressTxt,
			&i.QualityChecks,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DelegationMode,
			&i.RetryCount,
			&i.ScheduledAt,
			&i.RetryAt,
			&i.StoriesTotal,
			&i.StoriesPassed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetStuckTask = `-- name: ResetStuckTask :exec
UPDATE tasks SET status = 'backlog', agent_id = NULL, retry_count = 0, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

func (q *Queries) ResetStuckTask(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, resetStuckTask, id)
	return err
}

const resetTaskRetryCount = `-- name: ResetTaskRetryCount :exec
UPDATE tasks SET retry_count = 0 WHERE id = ?
`

func (q *Queries) ResetTaskRetryCount(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, resetTaskRetryCount, id)
	return err
}

const setTaskRetryAt = `-- name: SetTaskRetryAt :exec
UPDATE tasks SET retry_at = ?, status = 'backlog', updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type SetTaskRetryAtParams struct {
	RetryAt sql.NullTime `json:"retry_at"`
	ID      string       `json:"id"`
}

func (q *Queries) SetTaskRetryAt(ctx context.Context, arg SetTaskRetryAtParams) error {
	_, err := q.db.ExecContext(ctx, setTaskRetryAt, arg.RetryAt, arg.ID)
	return err
}

const setTaskScheduledAt = `-- name: SetTaskScheduledAt :exec
UPDATE tasks SET scheduled_at = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type SetTaskScheduledAtParams struct {
	ScheduledAt sql.NullTime `json:"scheduled_at"`
	ID          string       `json:"id"`
}

func (q *Queries) SetTaskScheduledAt(ctx context.Context, arg SetTaskScheduledAtParams) error {
	_, err := q.db.ExecContext(ctx, setTaskScheduledAt, arg.ScheduledAt, arg.ID)
	return err
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks SET
    title = ?, description = ?, agent_id = ?, project_id = ?, status = ?, priority = ?,
    project_md = ?, requirements_md = ?, roadmap_md = ?, state_md = ?,
    prd_json = ?, progress_txt = ?, git_branch = ?, quality_checks = ?,
    delegation_mode = ?, scheduled_at = ?, retry_at = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ? RETURNING id, title, description, agent_id, project_id, parent_task_id, status, priority, git_branch, project_md, requirements_md, roadmap_md, state_md, prd_json, progress_txt, quality_checks, created_at, updated_at, started_at, completed_at, delegation_mode, retry_count, scheduled_at, retry_at
`

type UpdateTaskParams struct {
	Title          string         `json:"title"`
	Description    sql.NullString `json:"description"`
	AgentID        sql.NullString `json:"agent_id"`
	ProjectID      sql.NullString `json:"project_id"`
	Status         sql.NullString `json:"status"`
	Priority       sql.NullInt64  `json:"priority"`
	ProjectMd      sql.NullString `json:"project_md"`
	RequirementsMd sql.NullString `json:"requirements_md"`
	RoadmapMd      sql.NullString `json:"roadmap_md"`
	StateMd        sql.NullString `json:"state_md"`
	PrdJson        sql.NullString `json:"prd_json"`
	ProgressTxt    sql.NullString `json:"progress_txt"`
	GitBranch      sql.NullString `json:"git_branch"`
	QualityChecks  sql.NullString `json:"quality_checks"`
	DelegationMode sql.NullString `json:"delegation_mode"`
	ScheduledAt    sql.NullTime   `json:"scheduled_at"`
	RetryAt        sql.NullTime   `json:"retry_at"`
	ID             string         `json:"id"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, updateTask,
		arg.Title,
		arg.Description,
		arg.AgentID,
		arg.ProjectID,
		arg.Status,
		arg.Priority,
		arg.ProjectMd,
		arg.RequirementsMd,
		arg.RoadmapMd,
		arg.StateMd,
		arg.PrdJson,
		arg.ProgressTxt,
		arg.GitBranch,
		arg.QualityChecks,
		arg.DelegationMode,
		arg.ScheduledAt,
		arg.RetryAt,
		arg.ID,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.AgentID,
		&i.ProjectID,
		&i.ParentTaskID,
		&i.Status,
		&i.Priority,
		&i.GitBranch,
		&i.ProjectMd,
		&i.RequirementsMd,
		&i.RoadmapMd,
		&i.StateMd,
		&i.PrdJson,
		&i.ProgressTxt,
		&i.QualityChecks,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DelegationMode,
		&i.RetryCount,
		&i.ScheduledAt,
		&i.RetryAt,
	)
	return i, err
}

const updateTaskStatus = `-- name: UpdateTaskStatus :exec
UPDATE tasks SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?
`

type UpdateTaskStatusParams struct {
	Status sql.NullString `json:"status"`
	ID     string         `json:"id"`
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTaskStatus, arg.Status, arg.ID)
	return err
}
